<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Slideshow</title>
    <style>
        body { 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start;
            min-height: 100vh; 
            margin: 0; 
            background-color: #f0f0f0; 
            padding: 10px; 
            box-sizing: border-box;
        }

        #slideshow-area { 
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: calc(100vh - 20px); /* bodyの上下paddingを引いた高さ */
            box-sizing: border-box;
        }

        #slide-container { 
            flex-grow: 1; /* 利用可能なスペースを埋める */
            min-height: 0;  /* flexアイテムが縮小できるようにする */
            width: auto;    /* aspect-ratio を活かすために auto にする */
            max-width: 90vw; /* ただし、ビューポート幅の90%を超えない */
            aspect-ratio: 16 / 9; 
            border: 1px solid #ccc; 
            background-color: white; 
            display: grid; 
            align-items: center; 
            justify-items: center; 
        }

        #slide-container img { 
            max-width: 100%; /* Added */
            max-height: 100%; /* Added */
            object-fit: contain; 
            object-position: center center; 
            grid-area: 1 / 1; /* Added for stacking in the same grid cell */
            opacity: 0; 
            transition: opacity 0.5s ease-in-out; 
        }
        #slide-container img.active { 
            opacity: 1; 
            z-index: 1; 
        }
        #controls { 
            flex-shrink: 0; /* コントロール部分は縮まない */
            width: 100%; /* 親の幅に合わせる */
            max-width: 90vw; /* スライドコンテナの最大幅に合わせる */
            display: flex; 
            flex-direction: row; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 10px; 
            padding: 5px 0; 
            box-sizing: border-box;
        }
        #nav-controls { 
            display: flex; 
            align-items: center; 
        }
        #media-controls { 
            display: flex; 
            align-items: center; 
        }
        #slideshow-autoplay-controls { 
            display: flex; 
            align-items: center; 
        }
        button { 
            padding: 5px 10px; /* Reduced padding */
            font-size: 12px; /* Reduced font size */
            cursor: pointer; 
            background-color: #007bff; 
            color: white; 
            border: none; 
            border-radius: 3px; /* Slightly reduced radius */
            margin: 0 5px; 
        }
        button:disabled { 
            background-color: #ccc; 
            cursor: not-allowed; 
        }
        #slide-counter { 
            font-size: 14px; /* Reduced font size */
            margin: 0 10px; /* Adjusted margin */
        }
        audio { 
            margin-top: 10px; 
        }
    </style>
</head>
<body>
    <div id="slideshow-area"> <!-- New parent container -->
        <div id="slide-container">
            <!-- Slides will be loaded here by JavaScript -->
        </div>
        <div id="controls">
            <div id="nav-controls">
                <button id="prev-btn">Previous</button>
                <span id="slide-counter">1 / 11</span>
                <button id="next-btn">Next</button>
            </div>
            <div id="media-controls">
                <div id="slideshow-autoplay-controls">
                    <button id="autoplay-toggle-btn">Autoplay</button>
                </div>
            </div>
        </div>
    </div> <!-- End of new parent container -->
    <audio id="slide-audio" style="display: none;"></audio>

    <script>
        // --- Configuration ---
        const slideImageBasePath = "salesforce_slides/salesforce_slides01/";
        const slideImagePrefix = "slide";
        const slideImageExtension = ".png";
        const audioBasePath = "salesforce_slides/salesforce_slides01/audio/";
        const audioFilePrefix = "salesforce_audio_";
        const audioFileExtension = ".wav";
        const totalSlides = 11;
        const audioFileNumberOffset = -1; // e.g., slide 1 maps to audio_0, so offset is -1
        const autoplayDelay = 3000; // milliseconds to wait after audio ends or if no audio
        // --- Keyboard Shortcut Configuration ---
        const longPressDuration = 500; // milliseconds to define a long press
        const seekInterval = 5;      // seconds to seek audio forward/backward
        const continuousSeekIntervalTime = 200; // milliseconds for continuous seek interval
        // --- End Configuration ---

        // --- Speaker Notes (Placeholder) ---
        const speakerNotesData = [
            "スライド1のノート：はじめに",
            "スライド2のノート：主要なポイントA",
            "スライド3のノート：主要なポイントB",
            "スライド4のノート：詳細解説1",
            "スライド5のノート：詳細解説2",
            "スライド6のノート：事例紹介",
            "スライド7のノート：データと統計",
            "スライド8のノート：お客様の声",
            "スライド9のノート：次のステップ",
            "スライド10のノート：Q&A",
            "スライド11のノート：まとめと感謝"
        ];
        // --- End Speaker Notes ---

        // --- BroadcastChannel Setup ---
        const channel = new BroadcastChannel('slideshow_channel');
        // --- End BroadcastChannel Setup ---

        let currentAudioPathForBroadcasting = null; // 追加: 現在のオーディオパスを保持

        const slideContainer = document.getElementById('slide-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const slideCounter = document.getElementById('slide-counter');
        
        const slideAudio = document.getElementById('slide-audio');

        const autoplayToggleBtn = document.getElementById('autoplay-toggle-btn');

        let currentSlide = 1;
        let isAutoplaying = false;
        let autoplayTimeoutId = null;

        function generateSlidePath(slideNumber) {
            const slidePadded = slideNumber.toString().padStart(2, '0');
            return `${slideImageBasePath}${slideImagePrefix}${slidePadded}${slideImageExtension}`;
        }

        function generateAudioPath(slideNumber) {
            if (slideNumber === 11) {
                // Slide 11 should have no audio, return a path that will intentionally cause an error
                return `${audioBasePath}no_audio_for_slide_11.wav`; 
            }
            const audioFileNumber = slideNumber + audioFileNumberOffset;
            return `${audioBasePath}${audioFilePrefix}${audioFileNumber}${audioFileExtension}`;
        }

        function displaySlide(slideNumber) {
            if (!slideAudio.paused) {
                slideAudio.pause();
            }
            slideAudio.currentTime = 0;

            const existingActiveImage = slideContainer.querySelector('img.active');
            if (existingActiveImage) {
                existingActiveImage.classList.remove('active');
            }

            let newSlideImage = slideContainer.querySelector(`img[data-slide-number="${slideNumber}"]`);
            if (!newSlideImage) {
                newSlideImage = document.createElement('img');
                newSlideImage.src = generateSlidePath(slideNumber);
                newSlideImage.alt = `Slide ${slideNumber}`;
                newSlideImage.dataset.slideNumber = slideNumber;
                slideContainer.appendChild(newSlideImage);
                newSlideImage.onload = () => {
                    newSlideImage.classList.add('active');
                };
            } else {
                 newSlideImage.classList.add('active');
            }

            slideCounter.textContent = `${slideNumber} / ${totalSlides}`;
            prevBtn.disabled = slideNumber === 1;
            nextBtn.disabled = slideNumber === totalSlides;

            const audioPath = generateAudioPath(slideNumber);
            currentAudioPathForBroadcasting = audioPath; // 追加: パスを保存
            slideAudio.src = audioPath;
            slideAudio.load(); // This will trigger 'loadedmetadata' or 'error'

            // --- Broadcast slide change (also includes audio info for presenter) ---
            channel.postMessage({
                type: 'slideChange',
                currentSlide: slideNumber,
                nextSlide: slideNumber < totalSlides ? slideNumber + 1 : null,
                totalSlides: totalSlides,
                notes: speakerNotesData[slideNumber - 1] || "ノートはありません。",
                isAutoplaying: isAutoplaying,
                audioSrc: currentAudioPathForBroadcasting, // 変更: 保持しているパスを使用
            });
            // --- End Broadcast slide change ---
        }

        function scheduleNextSlideIfAutoplaying() {
            if (!isAutoplaying) return;
            clearTimeout(autoplayTimeoutId);
            if (currentSlide < totalSlides) {
                autoplayTimeoutId = setTimeout(() => {
                    currentSlide++;
                    displaySlide(currentSlide);
                }, autoplayDelay);
            } else {
                stopAutoplay();
            }
        }

        function startAutoplay() {
            isAutoplaying = true;
            autoplayToggleBtn.textContent = 'Pause';
            console.log('Autoplay started');
            // --- Broadcast autoplay state change ---
            channel.postMessage({ type: 'autoplayStateChange', isAutoplaying: isAutoplaying });
            // --- End Broadcast autoplay state change ---

            if (slideAudio.src && !slideAudio.src.endsWith('null') && slideAudio.readyState >= HTMLMediaElement.HAVE_METADATA && !slideAudio.error) {
                slideAudio.play().catch(e => {
                    console.error("Error trying to play audio in startAutoplay:", e);
                    scheduleNextSlideIfAutoplaying();
                });
            } else if (slideAudio.error || !slideAudio.src || slideAudio.src.endsWith('null')) {
                console.log("No audio or audio error for current slide in startAutoplay, scheduling next.");
                scheduleNextSlideIfAutoplaying();
            }
        }

        function stopAutoplay(pauseTheAudio = true) {
            isAutoplaying = false;
            clearTimeout(autoplayTimeoutId);
            autoplayToggleBtn.textContent = 'Autoplay';
            if (pauseTheAudio && !slideAudio.paused) {
                slideAudio.pause();
            }
            console.log('Autoplay stopped');
            // --- Broadcast autoplay state change ---
            channel.postMessage({ type: 'autoplayStateChange', isAutoplaying: isAutoplaying });
            // --- End Broadcast autoplay state change ---
        }

        prevBtn.addEventListener('click', () => {
            if (isAutoplaying) {
                clearTimeout(autoplayTimeoutId); // 自動再生がオンの場合、現在のタイマーのみクリア
            }
            if (currentSlide > 1) {
                currentSlide--;
                displaySlide(currentSlide); // 新しいスライドを表示し、loadedmetadataが自動再生を処理
            }
        });

        nextBtn.addEventListener('click', () => {
            if (isAutoplaying) {
                clearTimeout(autoplayTimeoutId); // 自動再生がオンの場合、現在のタイマーのみクリア
            }
            if (currentSlide < totalSlides) {
                currentSlide++;
                displaySlide(currentSlide); // 新しいスライドを表示し、loadedmetadataが自動再生を処理
            }
        });

        slideAudio.addEventListener('loadedmetadata', () => {
            autoplayToggleBtn.disabled = false; // Enable autoplay button
            if (isAutoplaying) {
                slideAudio.play().catch(e => {
                    console.error("Error playing audio after metadata loaded in autoplay:", e);
                    scheduleNextSlideIfAutoplaying();
                });
            }
            // Inform presenter about audio duration
            channel.postMessage({
                type: 'audioMetadataLoaded',
                duration: slideAudio.duration,
                currentTime: slideAudio.currentTime,
                audioSrc: currentAudioPathForBroadcasting // 変更: 保持しているパスを使用
            });
        });

        slideAudio.addEventListener('timeupdate', () => {
            // Send current time to presenter
            channel.postMessage({
                type: 'audioTimeUpdate',
                currentTime: slideAudio.currentTime,
                duration: slideAudio.duration, // Also send duration for safety
                audioSrc: currentAudioPathForBroadcasting // 変更: 保持しているパスを使用
            });
        });

        slideAudio.addEventListener('ended', () => {
            if (isAutoplaying) {
                scheduleNextSlideIfAutoplaying();
            }
        });
        
        slideAudio.addEventListener('error', (e) => {
            console.error(`Error loading audio: ${slideAudio.src}`, e);
            autoplayToggleBtn.disabled = false; // Enable autoplay button even on error
            if (isAutoplaying) {
                scheduleNextSlideIfAutoplaying();
            }
            channel.postMessage({ // Inform presenter about the audio error
                type: 'audioError',
                audioSrc: currentAudioPathForBroadcasting // 変更: 保持しているパスを使用 (エラー時も統一)
            });
        });

        autoplayToggleBtn.addEventListener('click', () => {
            if (isAutoplaying) {
                stopAutoplay();
            } else {
                startAutoplay();
            }
        });
        
        autoplayToggleBtn.disabled = true;
        displaySlide(currentSlide);

        // --- BroadcastChannel Message Handler ---
        channel.onmessage = (event) => {
            const message = event.data;
            console.log('Message received from presenter:', message);

            switch (message.type) {
                case 'navigate':
                    if (message.direction === 'next' && currentSlide < totalSlides) {
                        nextBtn.click();
                    } else if (message.direction === 'prev' && currentSlide > 1) {
                        prevBtn.click();
                    }
                    break;
                case 'toggleAutoplay':
                    autoplayToggleBtn.click();
                    break;
                case 'requestInitialState':
                    // Send current state back to presenter
                    channel.postMessage({
                        type: 'slideChange',
                        currentSlide: currentSlide,
                        nextSlide: currentSlide < totalSlides ? currentSlide + 1 : null,
                        totalSlides: totalSlides,
                        notes: speakerNotesData[currentSlide - 1] || "ノートはありません。",
                        isAutoplaying: isAutoplaying,
                        audioSrc: currentAudioPathForBroadcasting, // 変更
                    });
                    // Additionally, if audio is loaded, send its current state
                    if (slideAudio.readyState >= HTMLMediaElement.HAVE_METADATA && !slideAudio.error) {
                        channel.postMessage({
                            type: 'audioMetadataLoaded',
                            duration: slideAudio.duration,
                            currentTime: slideAudio.currentTime,
                            audioSrc: currentAudioPathForBroadcasting // 変更
                        });
                    } else if (slideAudio.error) {
                         channel.postMessage({ type: 'audioError', audioSrc: currentAudioPathForBroadcasting }); // 変更
                    }
                    break;
                case 'seekAudio':
                    if (message.audioSrc === currentAudioPathForBroadcasting && message.time != null && slideAudio.readyState >= HTMLMediaElement.HAVE_METADATA && !slideAudio.error) {
                        slideAudio.currentTime = message.time;
                    }
                    break;
            }
        };
        // --- End BroadcastChannel Message Handler ---

        // --- Keyboard Shortcuts (Main View - Simplified) ---
        document.addEventListener('keydown', (event) => {
            if (event.key === ' ') {
                event.preventDefault(); 
                autoplayToggleBtn.click(); 
                return;
            }

            if (event.key === 'o' || event.key === 'O') {
                window.open('presenter_view.html', '_blank');
                return;
            }

            if (event.key === 'ArrowLeft') {
                if (event.repeat) return;
                prevBtn.click();
            } else if (event.key === 'ArrowRight') {
                if (event.repeat) return;
                nextBtn.click();
            }
        });
    </script>
</body>
</html>
