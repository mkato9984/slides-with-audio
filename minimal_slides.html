<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Slideshow</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; background-color: #f0f0f0; }
        #slide-container { width: 80%; max-width: 800px; aspect-ratio: 16 / 9; border: 1px solid #ccc; margin-bottom: 20px; position: relative; background-color: white; overflow: hidden; }
        #slide-container img { width: 100%; height: 100%; object-fit: contain; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.5s ease-in-out; }
        #slide-container img.active { opacity: 1; z-index: 1; }
        #controls { display: flex; flex-direction: column; align-items: center; width: 80%; max-width: 800px; margin-bottom: 10px; }
        #nav-controls { display: flex; align-items: center; margin-bottom: 10px; }
        #media-controls { display: flex; flex-direction: column; align-items: center; width: 100%; }
        #slideshow-autoplay-controls { display: flex; align-items: center; }
        button { padding: 10px 15px; font-size: 14px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; margin: 0 5px; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #slide-counter { font-size: 18px; margin: 0 15px; }
        audio { margin-top: 10px; } /* Styles for the audio player if it becomes visible */
    </style>
</head>
<body>
    <div id="slide-container">
        <!-- Slides will be loaded here by JavaScript -->
    </div>
    <div id="controls">
        <div id="nav-controls">
            <button id="prev-btn">Previous</button>
            <span id="slide-counter">1 / 11</span>
            <button id="next-btn">Next</button>
        </div>
        <div id="media-controls">
            <div id="slideshow-autoplay-controls">
                <button id="autoplay-toggle-btn">Autoplay</button>
            </div>
        </div>
    </div>
    <audio id="slide-audio" style="display: none;"></audio>

    <script>
        // --- Configuration ---
        const slideImageBasePath = "salesforce_slides/salesforce_slides01/";
        const slideImagePrefix = "slide";
        const slideImageExtension = ".png";
        const audioBasePath = "salesforce_slides/salesforce_slides01/audio/";
        const audioFilePrefix = "salesforce_audio_";
        const audioFileExtension = ".wav";
        const totalSlides = 11;
        const audioFileNumberOffset = -1; // e.g., slide 1 maps to audio_0, so offset is -1
        const autoplayDelay = 3000; // milliseconds to wait after audio ends or if no audio
        // --- Keyboard Shortcut Configuration ---
        const longPressDuration = 500; // milliseconds to define a long press
        const seekInterval = 5;      // seconds to seek audio forward/backward
        const continuousSeekIntervalTime = 200; // milliseconds for continuous seek interval
        // --- End Configuration ---

        // --- Speaker Notes (Placeholder) ---
        const speakerNotesData = [
            "スライド1のノート：はじめに",
            "スライド2のノート：主要なポイントA",
            "スライド3のノート：主要なポイントB",
            "スライド4のノート：詳細解説1",
            "スライド5のノート：詳細解説2",
            "スライド6のノート：事例紹介",
            "スライド7のノート：データと統計",
            "スライド8のノート：お客様の声",
            "スライド9のノート：次のステップ",
            "スライド10のノート：Q&A",
            "スライド11のノート：まとめと感謝"
        ];
        // --- End Speaker Notes ---

        // --- BroadcastChannel Setup ---
        const channel = new BroadcastChannel('slideshow_channel');
        // --- End BroadcastChannel Setup ---

        let currentAudioPathForBroadcasting = null; // 追加: 現在のオーディオパスを保持

        const slideContainer = document.getElementById('slide-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const slideCounter = document.getElementById('slide-counter');
        
        const slideAudio = document.getElementById('slide-audio');

        const autoplayToggleBtn = document.getElementById('autoplay-toggle-btn');

        let currentSlide = 1;
        let isAutoplaying = false;
        let autoplayTimeoutId = null;

        function generateSlidePath(slideNumber) {
            const slidePadded = slideNumber.toString().padStart(2, '0');
            return `${slideImageBasePath}${slideImagePrefix}${slidePadded}${slideImageExtension}`;
        }

        function generateAudioPath(slideNumber) {
            if (slideNumber === 11) {
                // Slide 11 should have no audio, return a path that will intentionally cause an error
                return `${audioBasePath}no_audio_for_slide_11.wav`; 
            }
            const audioFileNumber = slideNumber + audioFileNumberOffset;
            return `${audioBasePath}${audioFilePrefix}${audioFileNumber}${audioFileExtension}`;
        }

        function displaySlide(slideNumber) {
            if (!slideAudio.paused) {
                slideAudio.pause();
            }
            slideAudio.currentTime = 0;

            const existingActiveImage = slideContainer.querySelector('img.active');
            if (existingActiveImage) {
                existingActiveImage.classList.remove('active');
            }

            let newSlideImage = slideContainer.querySelector(`img[data-slide-number="${slideNumber}"]`);
            if (!newSlideImage) {
                newSlideImage = document.createElement('img');
                newSlideImage.src = generateSlidePath(slideNumber);
                newSlideImage.alt = `Slide ${slideNumber}`;
                newSlideImage.dataset.slideNumber = slideNumber;
                slideContainer.appendChild(newSlideImage);
                newSlideImage.onload = () => {
                    newSlideImage.classList.add('active');
                };
            } else {
                 newSlideImage.classList.add('active');
            }

            slideCounter.textContent = `${slideNumber} / ${totalSlides}`;
            prevBtn.disabled = slideNumber === 1;
            nextBtn.disabled = slideNumber === totalSlides;

            const audioPath = generateAudioPath(slideNumber);
            currentAudioPathForBroadcasting = audioPath; // 追加: パスを保存
            slideAudio.src = audioPath;
            slideAudio.load(); // This will trigger 'loadedmetadata' or 'error'

            // --- Broadcast slide change (also includes audio info for presenter) ---
            channel.postMessage({
                type: 'slideChange',
                currentSlide: slideNumber,
                nextSlide: slideNumber < totalSlides ? slideNumber + 1 : null,
                totalSlides: totalSlides,
                notes: speakerNotesData[slideNumber - 1] || "ノートはありません。",
                isAutoplaying: isAutoplaying,
                audioSrc: currentAudioPathForBroadcasting, // 変更: 保持しているパスを使用
            });
            // --- End Broadcast slide change ---
        }

        function scheduleNextSlideIfAutoplaying() {
            if (!isAutoplaying) return;
            clearTimeout(autoplayTimeoutId);
            if (currentSlide < totalSlides) {
                autoplayTimeoutId = setTimeout(() => {
                    currentSlide++;
                    displaySlide(currentSlide);
                }, autoplayDelay);
            } else {
                stopAutoplay();
            }
        }

        function startAutoplay() {
            isAutoplaying = true;
            autoplayToggleBtn.textContent = 'Pause';
            console.log('Autoplay started');
            // --- Broadcast autoplay state change ---
            channel.postMessage({ type: 'autoplayStateChange', isAutoplaying: isAutoplaying });
            // --- End Broadcast autoplay state change ---

            if (slideAudio.src && !slideAudio.src.endsWith('null') && slideAudio.readyState >= HTMLMediaElement.HAVE_METADATA && !slideAudio.error) {
                slideAudio.play().catch(e => {
                    console.error("Error trying to play audio in startAutoplay:", e);
                    scheduleNextSlideIfAutoplaying();
                });
            } else if (slideAudio.error || !slideAudio.src || slideAudio.src.endsWith('null')) {
                console.log("No audio or audio error for current slide in startAutoplay, scheduling next.");
                scheduleNextSlideIfAutoplaying();
            }
        }

        function stopAutoplay(pauseTheAudio = true) {
            isAutoplaying = false;
            clearTimeout(autoplayTimeoutId);
            autoplayToggleBtn.textContent = 'Autoplay';
            if (pauseTheAudio && !slideAudio.paused) {
                slideAudio.pause();
            }
            console.log('Autoplay stopped');
            // --- Broadcast autoplay state change ---
            channel.postMessage({ type: 'autoplayStateChange', isAutoplaying: isAutoplaying });
            // --- End Broadcast autoplay state change ---
        }

        prevBtn.addEventListener('click', () => {
            if (isAutoplaying) {
                clearTimeout(autoplayTimeoutId); // 自動再生がオンの場合、現在のタイマーのみクリア
            }
            if (currentSlide > 1) {
                currentSlide--;
                displaySlide(currentSlide); // 新しいスライドを表示し、loadedmetadataが自動再生を処理
            }
        });

        nextBtn.addEventListener('click', () => {
            if (isAutoplaying) {
                clearTimeout(autoplayTimeoutId); // 自動再生がオンの場合、現在のタイマーのみクリア
            }
            if (currentSlide < totalSlides) {
                currentSlide++;
                displaySlide(currentSlide); // 新しいスライドを表示し、loadedmetadataが自動再生を処理
            }
        });

        slideAudio.addEventListener('loadedmetadata', () => {
            autoplayToggleBtn.disabled = false; // Enable autoplay button
            if (isAutoplaying) {
                slideAudio.play().catch(e => {
                    console.error("Error playing audio after metadata loaded in autoplay:", e);
                    scheduleNextSlideIfAutoplaying();
                });
            }
            // Inform presenter about audio duration
            channel.postMessage({
                type: 'audioMetadataLoaded',
                duration: slideAudio.duration,
                currentTime: slideAudio.currentTime,
                audioSrc: currentAudioPathForBroadcasting // 変更: 保持しているパスを使用
            });
        });

        slideAudio.addEventListener('timeupdate', () => {
            // Send current time to presenter
            channel.postMessage({
                type: 'audioTimeUpdate',
                currentTime: slideAudio.currentTime,
                duration: slideAudio.duration, // Also send duration for safety
                audioSrc: currentAudioPathForBroadcasting // 変更: 保持しているパスを使用
            });
        });

        slideAudio.addEventListener('ended', () => {
            if (isAutoplaying) {
                scheduleNextSlideIfAutoplaying();
            }
        });
        
        slideAudio.addEventListener('error', (e) => {
            console.error(`Error loading audio: ${slideAudio.src}`, e);
            autoplayToggleBtn.disabled = false; // Enable autoplay button even on error
            if (isAutoplaying) {
                scheduleNextSlideIfAutoplaying();
            }
            channel.postMessage({ // Inform presenter about the audio error
                type: 'audioError',
                audioSrc: currentAudioPathForBroadcasting // 変更: 保持しているパスを使用 (エラー時も統一)
            });
        });

        autoplayToggleBtn.addEventListener('click', () => {
            if (isAutoplaying) {
                stopAutoplay();
            } else {
                startAutoplay();
            }
        });
        
        autoplayToggleBtn.disabled = true;
        displaySlide(currentSlide);

        // --- BroadcastChannel Message Handler ---
        channel.onmessage = (event) => {
            const message = event.data;
            console.log('Message received from presenter:', message);

            switch (message.type) {
                case 'navigate':
                    if (message.direction === 'next' && currentSlide < totalSlides) {
                        nextBtn.click();
                    } else if (message.direction === 'prev' && currentSlide > 1) {
                        prevBtn.click();
                    }
                    break;
                case 'toggleAutoplay':
                    autoplayToggleBtn.click();
                    break;
                case 'requestInitialState':
                    // Send current state back to presenter
                    channel.postMessage({
                        type: 'slideChange',
                        currentSlide: currentSlide,
                        nextSlide: currentSlide < totalSlides ? currentSlide + 1 : null,
                        totalSlides: totalSlides,
                        notes: speakerNotesData[currentSlide - 1] || "ノートはありません。",
                        isAutoplaying: isAutoplaying,
                        audioSrc: currentAudioPathForBroadcasting, // 変更
                    });
                    // Additionally, if audio is loaded, send its current state
                    if (slideAudio.readyState >= HTMLMediaElement.HAVE_METADATA && !slideAudio.error) {
                        channel.postMessage({
                            type: 'audioMetadataLoaded',
                            duration: slideAudio.duration,
                            currentTime: slideAudio.currentTime,
                            audioSrc: currentAudioPathForBroadcasting // 変更
                        });
                    } else if (slideAudio.error) {
                         channel.postMessage({ type: 'audioError', audioSrc: currentAudioPathForBroadcasting }); // 変更
                    }
                    break;
                case 'seekAudio':
                    if (message.audioSrc === currentAudioPathForBroadcasting && message.time != null && slideAudio.readyState >= HTMLMediaElement.HAVE_METADATA && !slideAudio.error) {
                        slideAudio.currentTime = message.time;
                    }
                    break;
            }
        };
        // --- End BroadcastChannel Message Handler ---

        // --- Keyboard Shortcuts (Main View - Simplified) ---
        document.addEventListener('keydown', (event) => {
            if (event.key === ' ') {
                event.preventDefault(); 
                autoplayToggleBtn.click(); 
                return;
            }

            if (event.key === 'o' || event.key === 'O') {
                window.open('presenter_view.html', '_blank');
                return;
            }

            if (event.key === 'ArrowLeft') {
                if (event.repeat) return;
                prevBtn.click();
            } else if (event.key === 'ArrowRight') {
                if (event.repeat) return;
                nextBtn.click();
            }
        });
    </script>
</body>
</html>
